{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1469099671000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1469099671000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1469099671000},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1469099671000},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1469099671000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1469099671000},{"_id":"source/_posts/ES6-generator-indeep.md","hash":"ed9605feabb12b24809994676ec854fce789c783","modified":1469099671000},{"_id":"source/_posts/Eslint开启ES7语法校验.md","hash":"d2ccb52d241566f887f71250878b9c03173d6457","modified":1469175071000},{"_id":"source/_posts/Javascrip-Date.md","hash":"d393ab77ecbe9092e3340b313170332147b61cc5","modified":1469154710000},{"_id":"source/_posts/Mac-升级到El-Capitan.md","hash":"08f14744c6794683d18e011656bdb44845910ecc","modified":1469099671000},{"_id":"source/_posts/Nodejs调用c-扩展.md","hash":"ae4689857bb7e4110d3c8477d8cd516e295c6251","modified":1528717427385},{"_id":"source/_posts/log4js在pm2运行时坑点.md","hash":"62e3262f6f19527b8003d152180bdb0017395691","modified":1530701642607},{"_id":"source/_posts/mac安装protobuf2-5-0.md","hash":"b4771c638c1aab219a7ef2d36537aae6ca696203","modified":1528275245765},{"_id":"source/_posts/node调试参数-debug与-debug-brk的区别.md","hash":"656562320ebff1bb4d1d97173aeb57fd0a0cfa4f","modified":1512550118635},{"_id":"source/_posts/typescript精华.md","hash":"fd16acb44ef3b7440b3ed3a3ed23d6abd1138411","modified":1527833023089},{"_id":"source/_posts/使用SSH-Tunnel远程调试Nodejs.md","hash":"093a01b3bcad10e3425d2a8944bb868a57e60cbc","modified":1527159703702},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1469099671000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1469099671000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1469099671000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1469099671000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1469099671000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1469099671000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1469099671000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1469099671000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1469099671000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1469099671000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1469099671000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1469099671000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1469099671000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1469099671000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1469099671000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1469099671000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1469099671000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1469099671000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1469099671000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1469099671000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1469099671000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1469099671000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1469099671000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"36eefe6332b86b66023a9884b754d305235846b4","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1469099671000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1469099671000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1469099671000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1469099671000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1469099671000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1469099671000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1469099671000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1469099671000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1469099671000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1469099671000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1469099671000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"ES6 generator详解","date":"2016-03-18T09:40:24.000Z","_content":"###迭代器\n\n###什么是Generator\n\n###Generator解决什么问题\n\n###协程\n\n###CO源码详解\n\n###koa异常处理机制\n\nTo be continue...\n","source":"_posts/ES6-generator-indeep.md","raw":"---\ntitle: ES6 generator详解\ndate: 2016-03-18 17:40:24\ntags:\n---\n###迭代器\n\n###什么是Generator\n\n###Generator解决什么问题\n\n###协程\n\n###CO源码详解\n\n###koa异常处理机制\n\nTo be continue...\n","slug":"ES6-generator-indeep","published":1,"updated":"2016-07-21T11:14:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj708y830000nzs6ujw5utmq","content":"<p>###迭代器</p>\n<p>###什么是Generator</p>\n<p>###Generator解决什么问题</p>\n<p>###协程</p>\n<p>###CO源码详解</p>\n<p>###koa异常处理机制</p>\n<p>To be continue…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###迭代器</p>\n<p>###什么是Generator</p>\n<p>###Generator解决什么问题</p>\n<p>###协程</p>\n<p>###CO源码详解</p>\n<p>###koa异常处理机制</p>\n<p>To be continue…</p>\n"},{"title":"Eslint开启ES7语法校验","date":"2016-05-27T03:05:53.000Z","_content":"\n## 问题\n\n目前eslint只支持ES6/ES2015，不支持spread object语法，经查发现spread object是ES7规范（还包括class properties,decorators,async/await）\n\n参考：https://github.com/eslint/eslint/issues/2532\n\n## 解决\n\n### 1. eslint语法检查：\n安装babel-eslint\n```\nnpm install babel-eslint --save-dev\n```\n倘若需要支持generator-star，object-shorthand等特性，需要安装eslint-plugin-babel\n```\nnpm install eslint-plugin-babel --save-dev\n```\n然后在配置文件.eslintrc.* 添加如下配置\n```\n{\n  \"parser\": \"babel-eslint\",\n  \"plugins\": [\n    \"babel\"\n  ]\n  # this is for object spread\n  \"parserOptions\": {\n      \"ecmaFeatures\": {\n          \"experimentalObjectRestSpread\": true\n      }\n  }\n}\n```\n\n#### 注意：\n此处有一个坑，倘若extend airbnb-base的规则，需要把generator-star-spacing规则off掉。\n具体在eslint-plugin-babel的gihub页面上有提及——“Finally enable all the rules you would like to use (remember to disable the original ones as well!).”\n```\n{\n  'rule': {\n    'generator-star-spacing': 0, // 需要把airbnb-base定义的这条规则off掉，否则babel-eslint在parse时会报错\n  }\n}\n```\n\n### 2. 代码运行：\n上一步只是eslint代码的语法检查配置，倘若需要代码能够执行ES7特性的代码，还需要添加一下babel插件。\n\n支持object-rest-spread特性，安装babel插件，babel-plugin-transform-object-rest-spread\n```\nnpm install babel-plugin-transform-object-rest-spread --save-dev\n```\n\n支持特性async/await, 安装如下插件：\n```\nnpm install babel-plugin-transform-runtime --save-dev\nnpm install babel-plugin-syntax-async-functions --save-dev\nnpm install babel-plugin-transform-async-to-module-method --save-dev\n```\n\n配置.babelrc文件，倘若是fis3里使用babel进行编译的话，则加到对应的babel options里\n```\n{\n    \"presets\": [\"es2015\", \"stage-3\"],\n    \"plugins\": [\n      \"transform-object-rest-spread\",\n      \"transform-runtime\",\n      \"syntax-async-functions\",\n      [\"transform-async-to-module-method\", {\n        \"module\": \"bluebird\",\n        \"method\": \"coroutine\"\n      }]\n    ]\n}\n\n```\n具体可参考stackoverflow的帖子：http://stackoverflow.com/questions/28708975/transpile-async-await-proposal-with-babel-js\n","source":"_posts/Eslint开启ES7语法校验.md","raw":"---\ntitle: Eslint开启ES7语法校验\ndate: 2016-05-27 11:05:53\ntags:\n---\n\n## 问题\n\n目前eslint只支持ES6/ES2015，不支持spread object语法，经查发现spread object是ES7规范（还包括class properties,decorators,async/await）\n\n参考：https://github.com/eslint/eslint/issues/2532\n\n## 解决\n\n### 1. eslint语法检查：\n安装babel-eslint\n```\nnpm install babel-eslint --save-dev\n```\n倘若需要支持generator-star，object-shorthand等特性，需要安装eslint-plugin-babel\n```\nnpm install eslint-plugin-babel --save-dev\n```\n然后在配置文件.eslintrc.* 添加如下配置\n```\n{\n  \"parser\": \"babel-eslint\",\n  \"plugins\": [\n    \"babel\"\n  ]\n  # this is for object spread\n  \"parserOptions\": {\n      \"ecmaFeatures\": {\n          \"experimentalObjectRestSpread\": true\n      }\n  }\n}\n```\n\n#### 注意：\n此处有一个坑，倘若extend airbnb-base的规则，需要把generator-star-spacing规则off掉。\n具体在eslint-plugin-babel的gihub页面上有提及——“Finally enable all the rules you would like to use (remember to disable the original ones as well!).”\n```\n{\n  'rule': {\n    'generator-star-spacing': 0, // 需要把airbnb-base定义的这条规则off掉，否则babel-eslint在parse时会报错\n  }\n}\n```\n\n### 2. 代码运行：\n上一步只是eslint代码的语法检查配置，倘若需要代码能够执行ES7特性的代码，还需要添加一下babel插件。\n\n支持object-rest-spread特性，安装babel插件，babel-plugin-transform-object-rest-spread\n```\nnpm install babel-plugin-transform-object-rest-spread --save-dev\n```\n\n支持特性async/await, 安装如下插件：\n```\nnpm install babel-plugin-transform-runtime --save-dev\nnpm install babel-plugin-syntax-async-functions --save-dev\nnpm install babel-plugin-transform-async-to-module-method --save-dev\n```\n\n配置.babelrc文件，倘若是fis3里使用babel进行编译的话，则加到对应的babel options里\n```\n{\n    \"presets\": [\"es2015\", \"stage-3\"],\n    \"plugins\": [\n      \"transform-object-rest-spread\",\n      \"transform-runtime\",\n      \"syntax-async-functions\",\n      [\"transform-async-to-module-method\", {\n        \"module\": \"bluebird\",\n        \"method\": \"coroutine\"\n      }]\n    ]\n}\n\n```\n具体可参考stackoverflow的帖子：http://stackoverflow.com/questions/28708975/transpile-async-await-proposal-with-babel-js\n","slug":"Eslint开启ES7语法校验","published":1,"updated":"2016-07-22T08:11:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj708y8c0001nzs6jign88w1","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>目前eslint只支持ES6/ES2015，不支持spread object语法，经查发现spread object是ES7规范（还包括class properties,decorators,async/await）</p>\n<p>参考：<a href=\"https://github.com/eslint/eslint/issues/2532\" target=\"_blank\" rel=\"noopener\">https://github.com/eslint/eslint/issues/2532</a></p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><h3 id=\"1-eslint语法检查：\"><a href=\"#1-eslint语法检查：\" class=\"headerlink\" title=\"1. eslint语法检查：\"></a>1. eslint语法检查：</h3><p>安装babel-eslint<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-eslint --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>倘若需要支持generator-star，object-shorthand等特性，需要安装eslint-plugin-babel<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint-plugin-babel --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>然后在配置文件.eslintrc.* 添加如下配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;parser&quot;: &quot;babel-eslint&quot;,</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">    &quot;babel&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  # this is for object spread</span><br><span class=\"line\">  &quot;parserOptions&quot;: &#123;</span><br><span class=\"line\">      &quot;ecmaFeatures&quot;: &#123;</span><br><span class=\"line\">          &quot;experimentalObjectRestSpread&quot;: true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>此处有一个坑，倘若extend airbnb-base的规则，需要把generator-star-spacing规则off掉。<br>具体在eslint-plugin-babel的gihub页面上有提及——“Finally enable all the rules you would like to use (remember to disable the original ones as well!).”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &apos;rule&apos;: &#123;</span><br><span class=\"line\">    &apos;generator-star-spacing&apos;: 0, // 需要把airbnb-base定义的这条规则off掉，否则babel-eslint在parse时会报错</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-代码运行：\"><a href=\"#2-代码运行：\" class=\"headerlink\" title=\"2. 代码运行：\"></a>2. 代码运行：</h3><p>上一步只是eslint代码的语法检查配置，倘若需要代码能够执行ES7特性的代码，还需要添加一下babel插件。</p>\n<p>支持object-rest-spread特性，安装babel插件，babel-plugin-transform-object-rest-spread<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-object-rest-spread --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>支持特性async/await, 安装如下插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-runtime --save-dev</span><br><span class=\"line\">npm install babel-plugin-syntax-async-functions --save-dev</span><br><span class=\"line\">npm install babel-plugin-transform-async-to-module-method --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>配置.babelrc文件，倘若是fis3里使用babel进行编译的话，则加到对应的babel options里<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-3&quot;],</span><br><span class=\"line\">    &quot;plugins&quot;: [</span><br><span class=\"line\">      &quot;transform-object-rest-spread&quot;,</span><br><span class=\"line\">      &quot;transform-runtime&quot;,</span><br><span class=\"line\">      &quot;syntax-async-functions&quot;,</span><br><span class=\"line\">      [&quot;transform-async-to-module-method&quot;, &#123;</span><br><span class=\"line\">        &quot;module&quot;: &quot;bluebird&quot;,</span><br><span class=\"line\">        &quot;method&quot;: &quot;coroutine&quot;</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体可参考stackoverflow的帖子：<a href=\"http://stackoverflow.com/questions/28708975/transpile-async-await-proposal-with-babel-js\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/28708975/transpile-async-await-proposal-with-babel-js</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>目前eslint只支持ES6/ES2015，不支持spread object语法，经查发现spread object是ES7规范（还包括class properties,decorators,async/await）</p>\n<p>参考：<a href=\"https://github.com/eslint/eslint/issues/2532\" target=\"_blank\" rel=\"noopener\">https://github.com/eslint/eslint/issues/2532</a></p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><h3 id=\"1-eslint语法检查：\"><a href=\"#1-eslint语法检查：\" class=\"headerlink\" title=\"1. eslint语法检查：\"></a>1. eslint语法检查：</h3><p>安装babel-eslint<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-eslint --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>倘若需要支持generator-star，object-shorthand等特性，需要安装eslint-plugin-babel<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint-plugin-babel --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>然后在配置文件.eslintrc.* 添加如下配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;parser&quot;: &quot;babel-eslint&quot;,</span><br><span class=\"line\">  &quot;plugins&quot;: [</span><br><span class=\"line\">    &quot;babel&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  # this is for object spread</span><br><span class=\"line\">  &quot;parserOptions&quot;: &#123;</span><br><span class=\"line\">      &quot;ecmaFeatures&quot;: &#123;</span><br><span class=\"line\">          &quot;experimentalObjectRestSpread&quot;: true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>此处有一个坑，倘若extend airbnb-base的规则，需要把generator-star-spacing规则off掉。<br>具体在eslint-plugin-babel的gihub页面上有提及——“Finally enable all the rules you would like to use (remember to disable the original ones as well!).”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &apos;rule&apos;: &#123;</span><br><span class=\"line\">    &apos;generator-star-spacing&apos;: 0, // 需要把airbnb-base定义的这条规则off掉，否则babel-eslint在parse时会报错</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-代码运行：\"><a href=\"#2-代码运行：\" class=\"headerlink\" title=\"2. 代码运行：\"></a>2. 代码运行：</h3><p>上一步只是eslint代码的语法检查配置，倘若需要代码能够执行ES7特性的代码，还需要添加一下babel插件。</p>\n<p>支持object-rest-spread特性，安装babel插件，babel-plugin-transform-object-rest-spread<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-object-rest-spread --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>支持特性async/await, 安装如下插件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-plugin-transform-runtime --save-dev</span><br><span class=\"line\">npm install babel-plugin-syntax-async-functions --save-dev</span><br><span class=\"line\">npm install babel-plugin-transform-async-to-module-method --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>配置.babelrc文件，倘若是fis3里使用babel进行编译的话，则加到对应的babel options里<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-3&quot;],</span><br><span class=\"line\">    &quot;plugins&quot;: [</span><br><span class=\"line\">      &quot;transform-object-rest-spread&quot;,</span><br><span class=\"line\">      &quot;transform-runtime&quot;,</span><br><span class=\"line\">      &quot;syntax-async-functions&quot;,</span><br><span class=\"line\">      [&quot;transform-async-to-module-method&quot;, &#123;</span><br><span class=\"line\">        &quot;module&quot;: &quot;bluebird&quot;,</span><br><span class=\"line\">        &quot;method&quot;: &quot;coroutine&quot;</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>具体可参考stackoverflow的帖子：<a href=\"http://stackoverflow.com/questions/28708975/transpile-async-await-proposal-with-babel-js\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/28708975/transpile-async-await-proposal-with-babel-js</a></p>\n"},{"title":"Javascrip Date","date":"2016-07-21T11:22:08.000Z","_content":"\n1. 一些概念\n\n  UTC：英文「Coordinated Universal Time」／法文「Temps Universel Coordonné」）中文：世界标准时间。简单来说便是0度经线的时间。北京处于东八区，写作UTC+8;\n  GMT：格林尼治标准时间，是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间。理论上来说，GMT应该等于UTC。\n\n2. 时间的初始化\n  ```\n  Date()\n  ```     \n\n3. 遇见的坑\n\n  问题描述：项目中使用cookies(https://github.com/pillarjs/cookies)，设置资源的过期时间为8个小时以后，但是发现无论如何设置，浏览器上的cookie expired time都为当前时间。\n\n  原因：阅读代码（v0.6.1）发现，第148行（如下）调用toUTCString()，恰好我们所处的市区为东8区，toUTCString获取时间恰好差8个小时，因此在浏览器永远都是cookies刚返回就失效的状况。\n\n  ```\n    if (this.expires  ) header += \"; expires=\" + this.expires.toUTCString()\n  ```\n\n4. 时间的格式化以及不同浏览器的差异\n","source":"_posts/Javascrip-Date.md","raw":"---\ntitle: Javascrip Date\ndate: 2016-07-21 19:22:08\ntags:\n---\n\n1. 一些概念\n\n  UTC：英文「Coordinated Universal Time」／法文「Temps Universel Coordonné」）中文：世界标准时间。简单来说便是0度经线的时间。北京处于东八区，写作UTC+8;\n  GMT：格林尼治标准时间，是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间。理论上来说，GMT应该等于UTC。\n\n2. 时间的初始化\n  ```\n  Date()\n  ```     \n\n3. 遇见的坑\n\n  问题描述：项目中使用cookies(https://github.com/pillarjs/cookies)，设置资源的过期时间为8个小时以后，但是发现无论如何设置，浏览器上的cookie expired time都为当前时间。\n\n  原因：阅读代码（v0.6.1）发现，第148行（如下）调用toUTCString()，恰好我们所处的市区为东8区，toUTCString获取时间恰好差8个小时，因此在浏览器永远都是cookies刚返回就失效的状况。\n\n  ```\n    if (this.expires  ) header += \"; expires=\" + this.expires.toUTCString()\n  ```\n\n4. 时间的格式化以及不同浏览器的差异\n","slug":"Javascrip-Date","published":1,"updated":"2016-07-22T02:31:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj708y8f0002nzs6x6p4yilw","content":"<ol>\n<li><p>一些概念</p>\n<p>UTC：英文「Coordinated Universal Time」／法文「Temps Universel Coordonné」）中文：世界标准时间。简单来说便是0度经线的时间。北京处于东八区，写作UTC+8;<br>GMT：格林尼治标准时间，是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间。理论上来说，GMT应该等于UTC。</p>\n</li>\n<li><p>时间的初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  Date()</span><br><span class=\"line\">  ```     </span><br><span class=\"line\"></span><br><span class=\"line\">3. 遇见的坑</span><br><span class=\"line\"></span><br><span class=\"line\">  问题描述：项目中使用cookies(https://github.com/pillarjs/cookies)，设置资源的过期时间为8个小时以后，但是发现无论如何设置，浏览器上的cookie expired time都为当前时间。</span><br><span class=\"line\"></span><br><span class=\"line\">  原因：阅读代码（v0.6.1）发现，第148行（如下）调用toUTCString()，恰好我们所处的市区为东8区，toUTCString获取时间恰好差8个小时，因此在浏览器永远都是cookies刚返回就失效的状况。</span><br></pre></td></tr></table></figure>\n<p> if (this.expires  ) header += “; expires=” + this.expires.toUTCString()<br>```</p>\n</li>\n<li><p>时间的格式化以及不同浏览器的差异</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>一些概念</p>\n<p>UTC：英文「Coordinated Universal Time」／法文「Temps Universel Coordonné」）中文：世界标准时间。简单来说便是0度经线的时间。北京处于东八区，写作UTC+8;<br>GMT：格林尼治标准时间，是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间。理论上来说，GMT应该等于UTC。</p>\n</li>\n<li><p>时间的初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  Date()</span><br><span class=\"line\">  ```     </span><br><span class=\"line\"></span><br><span class=\"line\">3. 遇见的坑</span><br><span class=\"line\"></span><br><span class=\"line\">  问题描述：项目中使用cookies(https://github.com/pillarjs/cookies)，设置资源的过期时间为8个小时以后，但是发现无论如何设置，浏览器上的cookie expired time都为当前时间。</span><br><span class=\"line\"></span><br><span class=\"line\">  原因：阅读代码（v0.6.1）发现，第148行（如下）调用toUTCString()，恰好我们所处的市区为东8区，toUTCString获取时间恰好差8个小时，因此在浏览器永远都是cookies刚返回就失效的状况。</span><br></pre></td></tr></table></figure>\n<p> if (this.expires  ) header += “; expires=” + this.expires.toUTCString()<br>```</p>\n</li>\n<li><p>时间的格式化以及不同浏览器的差异</p>\n</li>\n</ol>\n"},{"title":"Mac 升级到El Capitan","date":"2016-04-15T02:10:06.000Z","_content":"\n### 问题\n\n    通过App Store跟新El Capitan，过程奇慢无比，几乎是不可能完成。下面是可行的更新办法。\n\n### 更新步骤\n\n1. 抓取升级包的下载链接\n    目前网上有提供升级包的下载链接，但是几乎都出自同一篇文章，且该链接已经过时。为保险起见，还是自己手动抓包比较靠谱。抓包工具可选wireshark或Charles。因为本机只装了wireshark，因此用wireshark抓取，选中网卡eth0，Capture Filter选中TCP or UDP port 80 (HTTP)。打开App Store，点击升级El Capitan。抓取到链接如下：\n\n    ```\n    http://osxapps.itunes.apple.com/apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/encrypted226869791772508350.pkg\n    ```\n\n2. 使用迅雷等工具下载刚才抓取的pkg包\n\n3. 搭建本地代理服务器\n    这步的作用是将App Store更新时将目标服务器指向本地，具体步骤如下：\n    ```\n    #create a tmp folder\n    mkdir elCapitanRoot && cd elCapitanRoot\n\n    #create a folder structure to match apple server\n    sudo mkdir -p ./apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/\n\n    #move downloaded pkg file to proper path\n    sudo mv ../encrypted226869791772508350.pkg ./apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/\n\n    #start a web server when you are in \"elCapitanRoot\" folder\n    sudo python -m SimpleHTTPServer 80\n\n    #修改hosts文件\n    sudo echo \"127.0.0.1 \tosxapps.itunes.apple.com\" >> /etc/hosts\n    ```\n    以上步骤完成之后，就可以到App Store里重新升级了，此时就能看见更新速度和火箭一般。更新完成之后，记得把hosts改回来，不然以后就没法更新其它软件了。\n\n4. 至此就进入常规步骤，整个安装过程大概会花费30分钟吧。\n\n5. 题外话：在第一步时还经常会遇见更新软件时经常碰到的坑：“进入已购项目，但是提示请等待，无法下载。也无法取消 ”，这就需要删除本地缓存，然后重新更新。清除缓存步骤如下：\n\n    1. 强制退出App Store\n    2. 进入下载缓存目录，在终端输入：\n    ```\n    sudo open $TMPDIR/../C/\n    ```\n    3. 直接删除com.apple.appstore 目录\n    4. 启动 Mac的 App Store，重新下载。\n\n### 参考\n\n    https://gist.github.com/rahul286/2fc41942c7ed4039893f\n    http://www.jianshu.com/p/3cb89725da64\n","source":"_posts/Mac-升级到El-Capitan.md","raw":"---\ntitle: Mac 升级到El Capitan\ndate: 2016-04-15 10:10:06\ntags: Mac\n---\n\n### 问题\n\n    通过App Store跟新El Capitan，过程奇慢无比，几乎是不可能完成。下面是可行的更新办法。\n\n### 更新步骤\n\n1. 抓取升级包的下载链接\n    目前网上有提供升级包的下载链接，但是几乎都出自同一篇文章，且该链接已经过时。为保险起见，还是自己手动抓包比较靠谱。抓包工具可选wireshark或Charles。因为本机只装了wireshark，因此用wireshark抓取，选中网卡eth0，Capture Filter选中TCP or UDP port 80 (HTTP)。打开App Store，点击升级El Capitan。抓取到链接如下：\n\n    ```\n    http://osxapps.itunes.apple.com/apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/encrypted226869791772508350.pkg\n    ```\n\n2. 使用迅雷等工具下载刚才抓取的pkg包\n\n3. 搭建本地代理服务器\n    这步的作用是将App Store更新时将目标服务器指向本地，具体步骤如下：\n    ```\n    #create a tmp folder\n    mkdir elCapitanRoot && cd elCapitanRoot\n\n    #create a folder structure to match apple server\n    sudo mkdir -p ./apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/\n\n    #move downloaded pkg file to proper path\n    sudo mv ../encrypted226869791772508350.pkg ./apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/\n\n    #start a web server when you are in \"elCapitanRoot\" folder\n    sudo python -m SimpleHTTPServer 80\n\n    #修改hosts文件\n    sudo echo \"127.0.0.1 \tosxapps.itunes.apple.com\" >> /etc/hosts\n    ```\n    以上步骤完成之后，就可以到App Store里重新升级了，此时就能看见更新速度和火箭一般。更新完成之后，记得把hosts改回来，不然以后就没法更新其它软件了。\n\n4. 至此就进入常规步骤，整个安装过程大概会花费30分钟吧。\n\n5. 题外话：在第一步时还经常会遇见更新软件时经常碰到的坑：“进入已购项目，但是提示请等待，无法下载。也无法取消 ”，这就需要删除本地缓存，然后重新更新。清除缓存步骤如下：\n\n    1. 强制退出App Store\n    2. 进入下载缓存目录，在终端输入：\n    ```\n    sudo open $TMPDIR/../C/\n    ```\n    3. 直接删除com.apple.appstore 目录\n    4. 启动 Mac的 App Store，重新下载。\n\n### 参考\n\n    https://gist.github.com/rahul286/2fc41942c7ed4039893f\n    http://www.jianshu.com/p/3cb89725da64\n","slug":"Mac-升级到El-Capitan","published":1,"updated":"2016-07-21T11:14:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj708y8h0003nzs6q7x7aakw","content":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><pre><code>通过App Store跟新El Capitan，过程奇慢无比，几乎是不可能完成。下面是可行的更新办法。\n</code></pre><h3 id=\"更新步骤\"><a href=\"#更新步骤\" class=\"headerlink\" title=\"更新步骤\"></a>更新步骤</h3><ol>\n<li><p>抓取升级包的下载链接<br> 目前网上有提供升级包的下载链接，但是几乎都出自同一篇文章，且该链接已经过时。为保险起见，还是自己手动抓包比较靠谱。抓包工具可选wireshark或Charles。因为本机只装了wireshark，因此用wireshark抓取，选中网卡eth0，Capture Filter选中TCP or UDP port 80 (HTTP)。打开App Store，点击升级El Capitan。抓取到链接如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://osxapps.itunes.apple.com/apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/encrypted226869791772508350.pkg</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用迅雷等工具下载刚才抓取的pkg包</p>\n</li>\n<li><p>搭建本地代理服务器<br> 这步的作用是将App Store更新时将目标服务器指向本地，具体步骤如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#create a tmp folder</span><br><span class=\"line\">mkdir elCapitanRoot &amp;&amp; cd elCapitanRoot</span><br><span class=\"line\"></span><br><span class=\"line\">#create a folder structure to match apple server</span><br><span class=\"line\">sudo mkdir -p ./apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/</span><br><span class=\"line\"></span><br><span class=\"line\">#move downloaded pkg file to proper path</span><br><span class=\"line\">sudo mv ../encrypted226869791772508350.pkg ./apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/</span><br><span class=\"line\"></span><br><span class=\"line\">#start a web server when you are in &quot;elCapitanRoot&quot; folder</span><br><span class=\"line\">sudo python -m SimpleHTTPServer 80</span><br><span class=\"line\"></span><br><span class=\"line\">#修改hosts文件</span><br><span class=\"line\">sudo echo &quot;127.0.0.1 \tosxapps.itunes.apple.com&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>\n<p> 以上步骤完成之后，就可以到App Store里重新升级了，此时就能看见更新速度和火箭一般。更新完成之后，记得把hosts改回来，不然以后就没法更新其它软件了。</p>\n</li>\n<li><p>至此就进入常规步骤，整个安装过程大概会花费30分钟吧。</p>\n</li>\n<li><p>题外话：在第一步时还经常会遇见更新软件时经常碰到的坑：“进入已购项目，但是提示请等待，无法下载。也无法取消 ”，这就需要删除本地缓存，然后重新更新。清除缓存步骤如下：</p>\n<ol>\n<li>强制退出App Store</li>\n<li><p>进入下载缓存目录，在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo open $TMPDIR/../C/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接删除com.apple.appstore 目录</p>\n</li>\n<li>启动 Mac的 App Store，重新下载。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><pre><code>https://gist.github.com/rahul286/2fc41942c7ed4039893f\nhttp://www.jianshu.com/p/3cb89725da64\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><pre><code>通过App Store跟新El Capitan，过程奇慢无比，几乎是不可能完成。下面是可行的更新办法。\n</code></pre><h3 id=\"更新步骤\"><a href=\"#更新步骤\" class=\"headerlink\" title=\"更新步骤\"></a>更新步骤</h3><ol>\n<li><p>抓取升级包的下载链接<br> 目前网上有提供升级包的下载链接，但是几乎都出自同一篇文章，且该链接已经过时。为保险起见，还是自己手动抓包比较靠谱。抓包工具可选wireshark或Charles。因为本机只装了wireshark，因此用wireshark抓取，选中网卡eth0，Capture Filter选中TCP or UDP port 80 (HTTP)。打开App Store，点击升级El Capitan。抓取到链接如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://osxapps.itunes.apple.com/apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/encrypted226869791772508350.pkg</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用迅雷等工具下载刚才抓取的pkg包</p>\n</li>\n<li><p>搭建本地代理服务器<br> 这步的作用是将App Store更新时将目标服务器指向本地，具体步骤如下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#create a tmp folder</span><br><span class=\"line\">mkdir elCapitanRoot &amp;&amp; cd elCapitanRoot</span><br><span class=\"line\"></span><br><span class=\"line\">#create a folder structure to match apple server</span><br><span class=\"line\">sudo mkdir -p ./apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/</span><br><span class=\"line\"></span><br><span class=\"line\">#move downloaded pkg file to proper path</span><br><span class=\"line\">sudo mv ../encrypted226869791772508350.pkg ./apple-assets-us-std-000001/Purple49/v4/de/57/69/de576928-f6f5-9384-8dd4-974e3fcca649/</span><br><span class=\"line\"></span><br><span class=\"line\">#start a web server when you are in &quot;elCapitanRoot&quot; folder</span><br><span class=\"line\">sudo python -m SimpleHTTPServer 80</span><br><span class=\"line\"></span><br><span class=\"line\">#修改hosts文件</span><br><span class=\"line\">sudo echo &quot;127.0.0.1 \tosxapps.itunes.apple.com&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>\n<p> 以上步骤完成之后，就可以到App Store里重新升级了，此时就能看见更新速度和火箭一般。更新完成之后，记得把hosts改回来，不然以后就没法更新其它软件了。</p>\n</li>\n<li><p>至此就进入常规步骤，整个安装过程大概会花费30分钟吧。</p>\n</li>\n<li><p>题外话：在第一步时还经常会遇见更新软件时经常碰到的坑：“进入已购项目，但是提示请等待，无法下载。也无法取消 ”，这就需要删除本地缓存，然后重新更新。清除缓存步骤如下：</p>\n<ol>\n<li>强制退出App Store</li>\n<li><p>进入下载缓存目录，在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo open $TMPDIR/../C/</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接删除com.apple.appstore 目录</p>\n</li>\n<li>启动 Mac的 App Store，重新下载。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><pre><code>https://gist.github.com/rahul286/2fc41942c7ed4039893f\nhttp://www.jianshu.com/p/3cb89725da64\n</code></pre>"},{"title":"Nodejs调用c++扩展","date":"2018-06-08T07:19:54.000Z","_content":"## 相关概念\n* V8\n  the C++ library Node.js currently uses to provide the JavaScript implementation. [V8 doc](https://v8docs.nodesource.com/)\n\n* libuv\n  The C library that implements the Node.js event loop, its worker threads and all of the asynchronous behaviors of the platform. [libuv doc](https://github.com/libuv/libuv)\n\n* Internal Node.js libraries\n  Node.js itself exports a number of C++ APIs that Addons can use — the most important of which is the node::ObjectWrap class. 位于node源码的src目录下。\n\n* node-gyp\n  a tool written specifically to compile Node.js Addons. This version is not made directly available for developers to use and is intended only to support the ability to use the npm install command to compile and install Addons.\n  [Linking to Node.js' own dependencies](https://nodejs.org/api/addons.html#addons_linking_to_node_js_own_dependencies)\n  [node-gyp doc](https://github.com/nodejs/node-gyp#installation)\n\n  when node-gyp runs, it will detect the node's version, and find the sources or headers in ~/.node-gyp. If it cannot find any sources or headers, it will download  either the full source tarball or just the headers. We can use the --nodedir flag pointing at a local Node.js source image.\n\n* binding.gyp\n  node-gyp在编译时，会读取addon根目录下的binding.gyp文件，然后build/目录下生产Makefile文件(Unix/MacOs)或者vcxproj文件(Windows)，文件结构如下：\n```\n  {\n    \"targets\": [\n      {\n        \"target_name\": \"hello\",\n        \"sources\": [ \"hello.cc\" ],\n        \"include_dirs\": [\n          \"<!(node -e \\\"require('nan')\\\")\"\n        ]\n      },{\n        \"target_name\": \"addon2\",\n        \"sources\": [ \"2/addon.cc\", \"2/myobject.cc\" ]\n      }\n    ]\n  }\n```\n\n* .node\n  .node文件是c++ addon经node-gyp编译后生成的动态链接库(相当于.dll或.so或.dylib)，一般位于build/Release/addon.node, 可供js调用. 底层通过process.dlopen(module, filename)函数加载(in node.cc)。\n  ```\n  const addon = require('./build/Release/addon')\n  addon.your_c_function()\n  ```\n  如果引入bindings包（见下节）可调用如下：\n  ```\n  const addon = require('bindings')('addon.node')\n  addon.your_c_function()\n  ```\n\n* node-bindings\n  [node-bindings doc](https://github.com/TooTallNate/node-bindings)\n\n* node-ffi\n  node-ffi is a Node.js addon for loading and calling dynamic libraries using pure JavaScript. It can be used to create bindings to native libraries without writing any C++ code.\n\n* Nan(Native Abstractions for Node.js)\n  A header file filled with macro and utility goodness for making add-on development for Node.js easier across versions 0.8, 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10.\n  [doc](https://github.com/nodejs/nan)\n\n* N-API(From v8.0.0)\n  N-API (pronounced N as in the letter, followed by API) is an API for building native Addons. It is independent from the underlying JavaScript runtime (ex V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate Addons from changes in the underlying JavaScript engine and allow modules compiled for one version to run on later versions of Node.js without recompilation.\n  [doc](https://nodejs.org/api/n-api.html)\n\n* node-addon-api\n  [doc](https://github.com/nodejs/node-addon-api)\n\n## 实现的三种方式\n  1. 直接使用Node.js和V8 API\n    -缺点：V8 API can, and has, changed dramatically from one V8 release to the next\n\n  2. Nan\n\n  3. 使用N-API\n\n  4. 使用node-ffi\n\n## 案例分析\n  [sharp](https://github.com/lovell/sharp)是一个Node.js的图像处理库，底层依赖c++图像库[libvips](https://github.com/jcupitt/libvips),下面通过分析sharp的构建过程，学习如何编写一个c++ addon\n\n  * 相关资源\n    https://github.com/lovell/sharp\n    https://github.com/lovell/sharp-libvips\n    https://github.com/lovell/package-libvips-darwin\n    https://github.com/jcupitt/libvips\n  * 安装过程\n    1. 执行npm install，将执行以下指令\n    ```bash\n    (node install/libvips && node install/dll-copy && prebuild-install) || (node-gyp rebuild && node install/dll-copy)\n    ```\n    其中install/libvips.js将根据platform和版本，从https://github.com/lovell/sharp-libvips/releases下载libvips依赖的动态链接库，此库将保存在vendor目录下，包含所有的动态链接库和头文件。sharp-libvips工程通过docker将不同平台依赖的包预先构建打包了。\n    2. 执行node-gyp rebuild\n    此命令将根据binding.gyp文件的描述，将c代码编译，生成目标文件build/Release/sharp.node。至此安装完成\n  \n\n## 参考\n  [C++ Addons](https://nodejs.org/api/addons.html)\n  [Node.js 原生模块开发方式变迁](https://cnodejs.org/topic/5957626dacfce9295ba072e0)\n  [N-API: Next generation Node.js APIs for native modules](https://medium.com/the-node-js-collection/n-api-next-generation-node-js-apis-for-native-modules-169af5235b06)","source":"_posts/Nodejs调用c-扩展.md","raw":"---\ntitle: Nodejs调用c++扩展\ndate: 2018-06-08 15:19:54\ntags:\n---\n## 相关概念\n* V8\n  the C++ library Node.js currently uses to provide the JavaScript implementation. [V8 doc](https://v8docs.nodesource.com/)\n\n* libuv\n  The C library that implements the Node.js event loop, its worker threads and all of the asynchronous behaviors of the platform. [libuv doc](https://github.com/libuv/libuv)\n\n* Internal Node.js libraries\n  Node.js itself exports a number of C++ APIs that Addons can use — the most important of which is the node::ObjectWrap class. 位于node源码的src目录下。\n\n* node-gyp\n  a tool written specifically to compile Node.js Addons. This version is not made directly available for developers to use and is intended only to support the ability to use the npm install command to compile and install Addons.\n  [Linking to Node.js' own dependencies](https://nodejs.org/api/addons.html#addons_linking_to_node_js_own_dependencies)\n  [node-gyp doc](https://github.com/nodejs/node-gyp#installation)\n\n  when node-gyp runs, it will detect the node's version, and find the sources or headers in ~/.node-gyp. If it cannot find any sources or headers, it will download  either the full source tarball or just the headers. We can use the --nodedir flag pointing at a local Node.js source image.\n\n* binding.gyp\n  node-gyp在编译时，会读取addon根目录下的binding.gyp文件，然后build/目录下生产Makefile文件(Unix/MacOs)或者vcxproj文件(Windows)，文件结构如下：\n```\n  {\n    \"targets\": [\n      {\n        \"target_name\": \"hello\",\n        \"sources\": [ \"hello.cc\" ],\n        \"include_dirs\": [\n          \"<!(node -e \\\"require('nan')\\\")\"\n        ]\n      },{\n        \"target_name\": \"addon2\",\n        \"sources\": [ \"2/addon.cc\", \"2/myobject.cc\" ]\n      }\n    ]\n  }\n```\n\n* .node\n  .node文件是c++ addon经node-gyp编译后生成的动态链接库(相当于.dll或.so或.dylib)，一般位于build/Release/addon.node, 可供js调用. 底层通过process.dlopen(module, filename)函数加载(in node.cc)。\n  ```\n  const addon = require('./build/Release/addon')\n  addon.your_c_function()\n  ```\n  如果引入bindings包（见下节）可调用如下：\n  ```\n  const addon = require('bindings')('addon.node')\n  addon.your_c_function()\n  ```\n\n* node-bindings\n  [node-bindings doc](https://github.com/TooTallNate/node-bindings)\n\n* node-ffi\n  node-ffi is a Node.js addon for loading and calling dynamic libraries using pure JavaScript. It can be used to create bindings to native libraries without writing any C++ code.\n\n* Nan(Native Abstractions for Node.js)\n  A header file filled with macro and utility goodness for making add-on development for Node.js easier across versions 0.8, 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10.\n  [doc](https://github.com/nodejs/nan)\n\n* N-API(From v8.0.0)\n  N-API (pronounced N as in the letter, followed by API) is an API for building native Addons. It is independent from the underlying JavaScript runtime (ex V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate Addons from changes in the underlying JavaScript engine and allow modules compiled for one version to run on later versions of Node.js without recompilation.\n  [doc](https://nodejs.org/api/n-api.html)\n\n* node-addon-api\n  [doc](https://github.com/nodejs/node-addon-api)\n\n## 实现的三种方式\n  1. 直接使用Node.js和V8 API\n    -缺点：V8 API can, and has, changed dramatically from one V8 release to the next\n\n  2. Nan\n\n  3. 使用N-API\n\n  4. 使用node-ffi\n\n## 案例分析\n  [sharp](https://github.com/lovell/sharp)是一个Node.js的图像处理库，底层依赖c++图像库[libvips](https://github.com/jcupitt/libvips),下面通过分析sharp的构建过程，学习如何编写一个c++ addon\n\n  * 相关资源\n    https://github.com/lovell/sharp\n    https://github.com/lovell/sharp-libvips\n    https://github.com/lovell/package-libvips-darwin\n    https://github.com/jcupitt/libvips\n  * 安装过程\n    1. 执行npm install，将执行以下指令\n    ```bash\n    (node install/libvips && node install/dll-copy && prebuild-install) || (node-gyp rebuild && node install/dll-copy)\n    ```\n    其中install/libvips.js将根据platform和版本，从https://github.com/lovell/sharp-libvips/releases下载libvips依赖的动态链接库，此库将保存在vendor目录下，包含所有的动态链接库和头文件。sharp-libvips工程通过docker将不同平台依赖的包预先构建打包了。\n    2. 执行node-gyp rebuild\n    此命令将根据binding.gyp文件的描述，将c代码编译，生成目标文件build/Release/sharp.node。至此安装完成\n  \n\n## 参考\n  [C++ Addons](https://nodejs.org/api/addons.html)\n  [Node.js 原生模块开发方式变迁](https://cnodejs.org/topic/5957626dacfce9295ba072e0)\n  [N-API: Next generation Node.js APIs for native modules](https://medium.com/the-node-js-collection/n-api-next-generation-node-js-apis-for-native-modules-169af5235b06)","slug":"Nodejs调用c-扩展","published":1,"updated":"2018-06-11T11:43:47.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj708y8k0004nzs6sbsmhouj","content":"<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><ul>\n<li><p>V8<br>the C++ library Node.js currently uses to provide the JavaScript implementation. <a href=\"https://v8docs.nodesource.com/\" target=\"_blank\" rel=\"noopener\">V8 doc</a></p>\n</li>\n<li><p>libuv<br>The C library that implements the Node.js event loop, its worker threads and all of the asynchronous behaviors of the platform. <a href=\"https://github.com/libuv/libuv\" target=\"_blank\" rel=\"noopener\">libuv doc</a></p>\n</li>\n<li><p>Internal Node.js libraries<br>Node.js itself exports a number of C++ APIs that Addons can use — the most important of which is the node::ObjectWrap class. 位于node源码的src目录下。</p>\n</li>\n<li><p>node-gyp<br>a tool written specifically to compile Node.js Addons. This version is not made directly available for developers to use and is intended only to support the ability to use the npm install command to compile and install Addons.<br><a href=\"https://nodejs.org/api/addons.html#addons_linking_to_node_js_own_dependencies\" target=\"_blank\" rel=\"noopener\">Linking to Node.js’ own dependencies</a><br><a href=\"https://github.com/nodejs/node-gyp#installation\" target=\"_blank\" rel=\"noopener\">node-gyp doc</a></p>\n<p>when node-gyp runs, it will detect the node’s version, and find the sources or headers in ~/.node-gyp. If it cannot find any sources or headers, it will download  either the full source tarball or just the headers. We can use the –nodedir flag pointing at a local Node.js source image.</p>\n</li>\n<li><p>binding.gyp<br>node-gyp在编译时，会读取addon根目录下的binding.gyp文件，然后build/目录下生产Makefile文件(Unix/MacOs)或者vcxproj文件(Windows)，文件结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;hello&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello.cc&quot; ],</span><br><span class=\"line\">      &quot;include_dirs&quot;: [</span><br><span class=\"line\">        &quot;&lt;!(node -e \\&quot;require(&apos;nan&apos;)\\&quot;)&quot;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;addon2&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;2/addon.cc&quot;, &quot;2/myobject.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>.node<br>.node文件是c++ addon经node-gyp编译后生成的动态链接库(相当于.dll或.so或.dylib)，一般位于build/Release/addon.node, 可供js调用. 底层通过process.dlopen(module, filename)函数加载(in node.cc)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const addon = require(&apos;./build/Release/addon&apos;)</span><br><span class=\"line\">addon.your_c_function()</span><br></pre></td></tr></table></figure>\n<p>如果引入bindings包（见下节）可调用如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const addon = require(&apos;bindings&apos;)(&apos;addon.node&apos;)</span><br><span class=\"line\">addon.your_c_function()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>node-bindings<br><a href=\"https://github.com/TooTallNate/node-bindings\" target=\"_blank\" rel=\"noopener\">node-bindings doc</a></p>\n</li>\n<li><p>node-ffi<br>node-ffi is a Node.js addon for loading and calling dynamic libraries using pure JavaScript. It can be used to create bindings to native libraries without writing any C++ code.</p>\n</li>\n<li><p>Nan(Native Abstractions for Node.js)<br>A header file filled with macro and utility goodness for making add-on development for Node.js easier across versions 0.8, 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10.<br><a href=\"https://github.com/nodejs/nan\" target=\"_blank\" rel=\"noopener\">doc</a></p>\n</li>\n<li><p>N-API(From v8.0.0)<br>N-API (pronounced N as in the letter, followed by API) is an API for building native Addons. It is independent from the underlying JavaScript runtime (ex V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate Addons from changes in the underlying JavaScript engine and allow modules compiled for one version to run on later versions of Node.js without recompilation.<br><a href=\"https://nodejs.org/api/n-api.html\" target=\"_blank\" rel=\"noopener\">doc</a></p>\n</li>\n<li><p>node-addon-api<br><a href=\"https://github.com/nodejs/node-addon-api\" target=\"_blank\" rel=\"noopener\">doc</a></p>\n</li>\n</ul>\n<h2 id=\"实现的三种方式\"><a href=\"#实现的三种方式\" class=\"headerlink\" title=\"实现的三种方式\"></a>实现的三种方式</h2><ol>\n<li><p>直接使用Node.js和V8 API<br>-缺点：V8 API can, and has, changed dramatically from one V8 release to the next</p>\n</li>\n<li><p>Nan</p>\n</li>\n<li><p>使用N-API</p>\n</li>\n<li><p>使用node-ffi</p>\n</li>\n</ol>\n<h2 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h2><p>  <a href=\"https://github.com/lovell/sharp\" target=\"_blank\" rel=\"noopener\">sharp</a>是一个Node.js的图像处理库，底层依赖c++图像库<a href=\"https://github.com/jcupitt/libvips\" target=\"_blank\" rel=\"noopener\">libvips</a>,下面通过分析sharp的构建过程，学习如何编写一个c++ addon</p>\n<ul>\n<li>相关资源<br><a href=\"https://github.com/lovell/sharp\" target=\"_blank\" rel=\"noopener\">https://github.com/lovell/sharp</a><br><a href=\"https://github.com/lovell/sharp-libvips\" target=\"_blank\" rel=\"noopener\">https://github.com/lovell/sharp-libvips</a><br><a href=\"https://github.com/lovell/package-libvips-darwin\" target=\"_blank\" rel=\"noopener\">https://github.com/lovell/package-libvips-darwin</a><br><a href=\"https://github.com/jcupitt/libvips\" target=\"_blank\" rel=\"noopener\">https://github.com/jcupitt/libvips</a></li>\n<li><p>安装过程</p>\n<ol>\n<li>执行npm install，将执行以下指令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(node install/libvips &amp;&amp; node install/dll-copy &amp;&amp; prebuild-install) || (node-gyp rebuild &amp;&amp; node install/dll-copy)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其中install/libvips.js将根据platform和版本，从<a href=\"https://github.com/lovell/sharp-libvips/releases下载libvips依赖的动态链接库，此库将保存在vendor目录下，包含所有的动态链接库和头文件。sharp-libvips工程通过docker将不同平台依赖的包预先构建打包了。\" target=\"_blank\" rel=\"noopener\">https://github.com/lovell/sharp-libvips/releases下载libvips依赖的动态链接库，此库将保存在vendor目录下，包含所有的动态链接库和头文件。sharp-libvips工程通过docker将不同平台依赖的包预先构建打包了。</a></p>\n<ol>\n<li>执行node-gyp rebuild<br>此命令将根据binding.gyp文件的描述，将c代码编译，生成目标文件build/Release/sharp.node。至此安装完成</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>  <a href=\"https://nodejs.org/api/addons.html\" target=\"_blank\" rel=\"noopener\">C++ Addons</a><br>  <a href=\"https://cnodejs.org/topic/5957626dacfce9295ba072e0\" target=\"_blank\" rel=\"noopener\">Node.js 原生模块开发方式变迁</a><br>  <a href=\"https://medium.com/the-node-js-collection/n-api-next-generation-node-js-apis-for-native-modules-169af5235b06\" target=\"_blank\" rel=\"noopener\">N-API: Next generation Node.js APIs for native modules</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><ul>\n<li><p>V8<br>the C++ library Node.js currently uses to provide the JavaScript implementation. <a href=\"https://v8docs.nodesource.com/\" target=\"_blank\" rel=\"noopener\">V8 doc</a></p>\n</li>\n<li><p>libuv<br>The C library that implements the Node.js event loop, its worker threads and all of the asynchronous behaviors of the platform. <a href=\"https://github.com/libuv/libuv\" target=\"_blank\" rel=\"noopener\">libuv doc</a></p>\n</li>\n<li><p>Internal Node.js libraries<br>Node.js itself exports a number of C++ APIs that Addons can use — the most important of which is the node::ObjectWrap class. 位于node源码的src目录下。</p>\n</li>\n<li><p>node-gyp<br>a tool written specifically to compile Node.js Addons. This version is not made directly available for developers to use and is intended only to support the ability to use the npm install command to compile and install Addons.<br><a href=\"https://nodejs.org/api/addons.html#addons_linking_to_node_js_own_dependencies\" target=\"_blank\" rel=\"noopener\">Linking to Node.js’ own dependencies</a><br><a href=\"https://github.com/nodejs/node-gyp#installation\" target=\"_blank\" rel=\"noopener\">node-gyp doc</a></p>\n<p>when node-gyp runs, it will detect the node’s version, and find the sources or headers in ~/.node-gyp. If it cannot find any sources or headers, it will download  either the full source tarball or just the headers. We can use the –nodedir flag pointing at a local Node.js source image.</p>\n</li>\n<li><p>binding.gyp<br>node-gyp在编译时，会读取addon根目录下的binding.gyp文件，然后build/目录下生产Makefile文件(Unix/MacOs)或者vcxproj文件(Windows)，文件结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;targets&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;hello&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;hello.cc&quot; ],</span><br><span class=\"line\">      &quot;include_dirs&quot;: [</span><br><span class=\"line\">        &quot;&lt;!(node -e \\&quot;require(&apos;nan&apos;)\\&quot;)&quot;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,&#123;</span><br><span class=\"line\">      &quot;target_name&quot;: &quot;addon2&quot;,</span><br><span class=\"line\">      &quot;sources&quot;: [ &quot;2/addon.cc&quot;, &quot;2/myobject.cc&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>.node<br>.node文件是c++ addon经node-gyp编译后生成的动态链接库(相当于.dll或.so或.dylib)，一般位于build/Release/addon.node, 可供js调用. 底层通过process.dlopen(module, filename)函数加载(in node.cc)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const addon = require(&apos;./build/Release/addon&apos;)</span><br><span class=\"line\">addon.your_c_function()</span><br></pre></td></tr></table></figure>\n<p>如果引入bindings包（见下节）可调用如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const addon = require(&apos;bindings&apos;)(&apos;addon.node&apos;)</span><br><span class=\"line\">addon.your_c_function()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>node-bindings<br><a href=\"https://github.com/TooTallNate/node-bindings\" target=\"_blank\" rel=\"noopener\">node-bindings doc</a></p>\n</li>\n<li><p>node-ffi<br>node-ffi is a Node.js addon for loading and calling dynamic libraries using pure JavaScript. It can be used to create bindings to native libraries without writing any C++ code.</p>\n</li>\n<li><p>Nan(Native Abstractions for Node.js)<br>A header file filled with macro and utility goodness for making add-on development for Node.js easier across versions 0.8, 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10.<br><a href=\"https://github.com/nodejs/nan\" target=\"_blank\" rel=\"noopener\">doc</a></p>\n</li>\n<li><p>N-API(From v8.0.0)<br>N-API (pronounced N as in the letter, followed by API) is an API for building native Addons. It is independent from the underlying JavaScript runtime (ex V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate Addons from changes in the underlying JavaScript engine and allow modules compiled for one version to run on later versions of Node.js without recompilation.<br><a href=\"https://nodejs.org/api/n-api.html\" target=\"_blank\" rel=\"noopener\">doc</a></p>\n</li>\n<li><p>node-addon-api<br><a href=\"https://github.com/nodejs/node-addon-api\" target=\"_blank\" rel=\"noopener\">doc</a></p>\n</li>\n</ul>\n<h2 id=\"实现的三种方式\"><a href=\"#实现的三种方式\" class=\"headerlink\" title=\"实现的三种方式\"></a>实现的三种方式</h2><ol>\n<li><p>直接使用Node.js和V8 API<br>-缺点：V8 API can, and has, changed dramatically from one V8 release to the next</p>\n</li>\n<li><p>Nan</p>\n</li>\n<li><p>使用N-API</p>\n</li>\n<li><p>使用node-ffi</p>\n</li>\n</ol>\n<h2 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h2><p>  <a href=\"https://github.com/lovell/sharp\" target=\"_blank\" rel=\"noopener\">sharp</a>是一个Node.js的图像处理库，底层依赖c++图像库<a href=\"https://github.com/jcupitt/libvips\" target=\"_blank\" rel=\"noopener\">libvips</a>,下面通过分析sharp的构建过程，学习如何编写一个c++ addon</p>\n<ul>\n<li>相关资源<br><a href=\"https://github.com/lovell/sharp\" target=\"_blank\" rel=\"noopener\">https://github.com/lovell/sharp</a><br><a href=\"https://github.com/lovell/sharp-libvips\" target=\"_blank\" rel=\"noopener\">https://github.com/lovell/sharp-libvips</a><br><a href=\"https://github.com/lovell/package-libvips-darwin\" target=\"_blank\" rel=\"noopener\">https://github.com/lovell/package-libvips-darwin</a><br><a href=\"https://github.com/jcupitt/libvips\" target=\"_blank\" rel=\"noopener\">https://github.com/jcupitt/libvips</a></li>\n<li><p>安装过程</p>\n<ol>\n<li>执行npm install，将执行以下指令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(node install/libvips &amp;&amp; node install/dll-copy &amp;&amp; prebuild-install) || (node-gyp rebuild &amp;&amp; node install/dll-copy)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其中install/libvips.js将根据platform和版本，从<a href=\"https://github.com/lovell/sharp-libvips/releases下载libvips依赖的动态链接库，此库将保存在vendor目录下，包含所有的动态链接库和头文件。sharp-libvips工程通过docker将不同平台依赖的包预先构建打包了。\" target=\"_blank\" rel=\"noopener\">https://github.com/lovell/sharp-libvips/releases下载libvips依赖的动态链接库，此库将保存在vendor目录下，包含所有的动态链接库和头文件。sharp-libvips工程通过docker将不同平台依赖的包预先构建打包了。</a></p>\n<ol>\n<li>执行node-gyp rebuild<br>此命令将根据binding.gyp文件的描述，将c代码编译，生成目标文件build/Release/sharp.node。至此安装完成</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>  <a href=\"https://nodejs.org/api/addons.html\" target=\"_blank\" rel=\"noopener\">C++ Addons</a><br>  <a href=\"https://cnodejs.org/topic/5957626dacfce9295ba072e0\" target=\"_blank\" rel=\"noopener\">Node.js 原生模块开发方式变迁</a><br>  <a href=\"https://medium.com/the-node-js-collection/n-api-next-generation-node-js-apis-for-native-modules-169af5235b06\" target=\"_blank\" rel=\"noopener\">N-API: Next generation Node.js APIs for native modules</a></p>\n"},{"title":"log4js在pm2运行时坑点","date":"2018-07-04T09:37:57.000Z","_content":"\n### 起因\n  近期对logger组件进行升级，使用log4js作为底层日志输出。在开发环境下通过node命令行启动程序，log能正常创建打印。但是在生产环境下，通过pm2启动程序后，发现日志文件无法正常创建。经过散弹枪式编程法跟踪后，发现当实例数量大于1时，日志文件无法正常创建。阅读源码发现是log4js与pm2配合的问题，而log4js的文档中并未提及该问题。\n\n### pm2以cluster模式启动程序时到底干了啥\n  既然上文说到与pm2有关，那么pm2是如何启动进程的呢？以下只讨论cluster模式。\n  我们都知道cluster模式启动进程时，将会产生一个master进程和N个worker进程，那么pm2在启动应用程序时谁是master，谁是worker？\n  实际上pm2启动进程时，master是pm2的内部进程，叫做God Daemon进程。所有的用户代码都是以worker进程的方式启动的。\n  在pm2的lib/God.js里有如一段代码：\n  ```js\n  cluster.setupMaster({\n    exec : path.resolve(path.dirname(module.filename), 'ProcessContainer.js')\n  });\n  ```\n  这段代码保证了在调用cluster.fork()方法时，pm2去加载用户代码，并在worker进程中执行。\n  对应pm2运行原理的分析，这里先告一个段落，接下来我们看看log4js的源码是如何处理多进程写日志以及如何创建日志文件的。\n\n### 多进程下，该如何写同一个日志文件？\n  多个进程同时写一个文件时会发生什么呢？参考：[多进程同时写一个文件会怎样？](https://blog.csdn.net/yangbodong22011/article/details/63064166)\n  为了避免多进程同时写一个日志文件，log4js的实现方式是：通过IPC传递消息，由一个进程去写。\n\n  log4js.configure()方法执行的内部有如下的一段代码：\n  ```js\n  if (config.disableClustering) {\n    debug('Not listening for cluster messages, because clustering disabled.');\n  } else if (isPM2Master()) {\n    // PM2 cluster support\n    // PM2 runs everything as workers - install pm2-intercom for this to work.\n    // we only want one of the app instances to write logs\n    debug(`listening for PM2 broadcast messages, ${process.pid}`);\n    process.on('message', receiver);\n  } else if (cluster.isMaster) {\n    debug(`listening for cluster messages, ${process.pid}`);\n    cluster.on('message', receiver);\n  } else {\n    debug('not listening for messages, because we are not a master process');\n  }\n  ```\n  由上面的源码可以看到，在isPM2Master和cluster.isMaster为true时会注册两个监听函数，当worker进程通过IPC发送消息时，将通过receiver接受消息，并在master中进行写入log的操作。上一节说到，pm2的master是God Daemon进程，进程里肯定不包含任何log4js的调用。那么在使用pm2时，由谁来写日志呢？关键就在于isPM2Master函数。\n\n### isPM2Master是如何工作的\n  那么接下来我们将看看isPM2Master()这个方法的具体实现：\n  ```js\n  function isPM2Master() {\n    return config.pm2 && process.env[config.pm2InstanceVar] === '0';\n  }\n  ```\n  我们看到有两个判断条件:\n  * 条件一: config.pm2可以通过log4js的配置文件指定，可设置为\"pm2=true\"\n  * 条件二: 从env里取环境变量config.pm2InstanceVar所代表的值，经运行发现默认情况下 pm2InstanceVar = NODE_APP_INSTANCE。\n\n  关于NODE_APP_INSTANCE环境变量，在pm2源码的CHANGE_LOG里有这样一段描述:\n  ```text\n    If we start let's say 4 instances of an app (cluster_mode),\n    Each app will have a value in process.env.NODE_APP_INSTANCE which will be 0 for the first one,\n    1, 2 and 3 for the next ones.\n  ```\n\n  意即，当pm2启动4个用户进程的实例时，这四个进程的process.env.NODE_APP_INSTANCE环境变量值分别为0,1,2,3\n\n  ** 由此可见，当我们在log4js的配置文件设置pm2=true时，log4js将取NODE_APP_INSTANCE=0的进程作为写日志的主进程，这就避免了多进程写**\n\n### 为什么pm2以多进程方式启动时，无法创建日志文件\n  最终问题回到了文章开头提到的现象，究竟是为什么导致了创建日志文件失败呢，我们看看源码。在configuration.js的createAppender方法里有这么一段：\n  ```js\n  if (this.disableClustering || cluster.isMaster || (this.pm2 && process.env[this.pm2InstanceVar] === '0')) {\n      // ...\n      const appender = appenderModule.configure(\n        config,\n        layouts,\n        this.configuredAppenders.get.bind(this.configuredAppenders),\n        this.configuredLevels\n      );\n  }\n  ```\n  可见(this.pm2 && process.env[this.pm2InstanceVar] === '0')就是我们上文提到的isPm2Master方法\n\n### 问题的解决\n  由此发现，解决这个问题的方式就是在log4js配置文件里加上pm2=true的选项，具体如下：\n  ```js\n  log4js.configure({\n    appenders: {\n      df: {\n        type: 'dateFile',\n        filename: '/Users/didi/Github/log4js-node/zhlin-logs/xxx.log',\n      },\n    },\n    categories: {\n      default: { appenders: ['df'], level: 'DEBUG' }\n    },\n    pm2: true,\n  });\n  ```","source":"_posts/log4js在pm2运行时坑点.md","raw":"---\ntitle: log4js在pm2运行时坑点\ndate: 2018-07-04 17:37:57\ntags:\n---\n\n### 起因\n  近期对logger组件进行升级，使用log4js作为底层日志输出。在开发环境下通过node命令行启动程序，log能正常创建打印。但是在生产环境下，通过pm2启动程序后，发现日志文件无法正常创建。经过散弹枪式编程法跟踪后，发现当实例数量大于1时，日志文件无法正常创建。阅读源码发现是log4js与pm2配合的问题，而log4js的文档中并未提及该问题。\n\n### pm2以cluster模式启动程序时到底干了啥\n  既然上文说到与pm2有关，那么pm2是如何启动进程的呢？以下只讨论cluster模式。\n  我们都知道cluster模式启动进程时，将会产生一个master进程和N个worker进程，那么pm2在启动应用程序时谁是master，谁是worker？\n  实际上pm2启动进程时，master是pm2的内部进程，叫做God Daemon进程。所有的用户代码都是以worker进程的方式启动的。\n  在pm2的lib/God.js里有如一段代码：\n  ```js\n  cluster.setupMaster({\n    exec : path.resolve(path.dirname(module.filename), 'ProcessContainer.js')\n  });\n  ```\n  这段代码保证了在调用cluster.fork()方法时，pm2去加载用户代码，并在worker进程中执行。\n  对应pm2运行原理的分析，这里先告一个段落，接下来我们看看log4js的源码是如何处理多进程写日志以及如何创建日志文件的。\n\n### 多进程下，该如何写同一个日志文件？\n  多个进程同时写一个文件时会发生什么呢？参考：[多进程同时写一个文件会怎样？](https://blog.csdn.net/yangbodong22011/article/details/63064166)\n  为了避免多进程同时写一个日志文件，log4js的实现方式是：通过IPC传递消息，由一个进程去写。\n\n  log4js.configure()方法执行的内部有如下的一段代码：\n  ```js\n  if (config.disableClustering) {\n    debug('Not listening for cluster messages, because clustering disabled.');\n  } else if (isPM2Master()) {\n    // PM2 cluster support\n    // PM2 runs everything as workers - install pm2-intercom for this to work.\n    // we only want one of the app instances to write logs\n    debug(`listening for PM2 broadcast messages, ${process.pid}`);\n    process.on('message', receiver);\n  } else if (cluster.isMaster) {\n    debug(`listening for cluster messages, ${process.pid}`);\n    cluster.on('message', receiver);\n  } else {\n    debug('not listening for messages, because we are not a master process');\n  }\n  ```\n  由上面的源码可以看到，在isPM2Master和cluster.isMaster为true时会注册两个监听函数，当worker进程通过IPC发送消息时，将通过receiver接受消息，并在master中进行写入log的操作。上一节说到，pm2的master是God Daemon进程，进程里肯定不包含任何log4js的调用。那么在使用pm2时，由谁来写日志呢？关键就在于isPM2Master函数。\n\n### isPM2Master是如何工作的\n  那么接下来我们将看看isPM2Master()这个方法的具体实现：\n  ```js\n  function isPM2Master() {\n    return config.pm2 && process.env[config.pm2InstanceVar] === '0';\n  }\n  ```\n  我们看到有两个判断条件:\n  * 条件一: config.pm2可以通过log4js的配置文件指定，可设置为\"pm2=true\"\n  * 条件二: 从env里取环境变量config.pm2InstanceVar所代表的值，经运行发现默认情况下 pm2InstanceVar = NODE_APP_INSTANCE。\n\n  关于NODE_APP_INSTANCE环境变量，在pm2源码的CHANGE_LOG里有这样一段描述:\n  ```text\n    If we start let's say 4 instances of an app (cluster_mode),\n    Each app will have a value in process.env.NODE_APP_INSTANCE which will be 0 for the first one,\n    1, 2 and 3 for the next ones.\n  ```\n\n  意即，当pm2启动4个用户进程的实例时，这四个进程的process.env.NODE_APP_INSTANCE环境变量值分别为0,1,2,3\n\n  ** 由此可见，当我们在log4js的配置文件设置pm2=true时，log4js将取NODE_APP_INSTANCE=0的进程作为写日志的主进程，这就避免了多进程写**\n\n### 为什么pm2以多进程方式启动时，无法创建日志文件\n  最终问题回到了文章开头提到的现象，究竟是为什么导致了创建日志文件失败呢，我们看看源码。在configuration.js的createAppender方法里有这么一段：\n  ```js\n  if (this.disableClustering || cluster.isMaster || (this.pm2 && process.env[this.pm2InstanceVar] === '0')) {\n      // ...\n      const appender = appenderModule.configure(\n        config,\n        layouts,\n        this.configuredAppenders.get.bind(this.configuredAppenders),\n        this.configuredLevels\n      );\n  }\n  ```\n  可见(this.pm2 && process.env[this.pm2InstanceVar] === '0')就是我们上文提到的isPm2Master方法\n\n### 问题的解决\n  由此发现，解决这个问题的方式就是在log4js配置文件里加上pm2=true的选项，具体如下：\n  ```js\n  log4js.configure({\n    appenders: {\n      df: {\n        type: 'dateFile',\n        filename: '/Users/didi/Github/log4js-node/zhlin-logs/xxx.log',\n      },\n    },\n    categories: {\n      default: { appenders: ['df'], level: 'DEBUG' }\n    },\n    pm2: true,\n  });\n  ```","slug":"log4js在pm2运行时坑点","published":1,"updated":"2018-07-04T10:54:37.161Z","_id":"cjj708y8t0006nzs6p81hjcaj","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>  近期对logger组件进行升级，使用log4js作为底层日志输出。在开发环境下通过node命令行启动程序，log能正常创建打印。但是在生产环境下，通过pm2启动程序后，发现日志文件无法正常创建。经过散弹枪式编程法跟踪后，发现当实例数量大于1时，日志文件无法正常创建。阅读源码发现是log4js与pm2配合的问题，而log4js的文档中并未提及该问题。</p>\n<h3 id=\"pm2以cluster模式启动程序时到底干了啥\"><a href=\"#pm2以cluster模式启动程序时到底干了啥\" class=\"headerlink\" title=\"pm2以cluster模式启动程序时到底干了啥\"></a>pm2以cluster模式启动程序时到底干了啥</h3><p>  既然上文说到与pm2有关，那么pm2是如何启动进程的呢？以下只讨论cluster模式。<br>  我们都知道cluster模式启动进程时，将会产生一个master进程和N个worker进程，那么pm2在启动应用程序时谁是master，谁是worker？<br>  实际上pm2启动进程时，master是pm2的内部进程，叫做God Daemon进程。所有的用户代码都是以worker进程的方式启动的。<br>  在pm2的lib/God.js里有如一段代码：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.setupMaster(&#123;</span><br><span class=\"line\">  exec : path.resolve(path.dirname(<span class=\"built_in\">module</span>.filename), <span class=\"string\">'ProcessContainer.js'</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  这段代码保证了在调用cluster.fork()方法时，pm2去加载用户代码，并在worker进程中执行。<br>  对应pm2运行原理的分析，这里先告一个段落，接下来我们看看log4js的源码是如何处理多进程写日志以及如何创建日志文件的。</p>\n<h3 id=\"多进程下，该如何写同一个日志文件？\"><a href=\"#多进程下，该如何写同一个日志文件？\" class=\"headerlink\" title=\"多进程下，该如何写同一个日志文件？\"></a>多进程下，该如何写同一个日志文件？</h3><p>  多个进程同时写一个文件时会发生什么呢？参考：<a href=\"https://blog.csdn.net/yangbodong22011/article/details/63064166\" target=\"_blank\" rel=\"noopener\">多进程同时写一个文件会怎样？</a><br>  为了避免多进程同时写一个日志文件，log4js的实现方式是：通过IPC传递消息，由一个进程去写。</p>\n<p>  log4js.configure()方法执行的内部有如下的一段代码：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (config.disableClustering) &#123;</span><br><span class=\"line\">  debug(<span class=\"string\">'Not listening for cluster messages, because clustering disabled.'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isPM2Master()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// PM2 cluster support</span></span><br><span class=\"line\">  <span class=\"comment\">// PM2 runs everything as workers - install pm2-intercom for this to work.</span></span><br><span class=\"line\">  <span class=\"comment\">// we only want one of the app instances to write logs</span></span><br><span class=\"line\">  debug(<span class=\"string\">`listening for PM2 broadcast messages, <span class=\"subst\">$&#123;process.pid&#125;</span>`</span>);</span><br><span class=\"line\">  process.on(<span class=\"string\">'message'</span>, receiver);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cluster.isMaster) &#123;</span><br><span class=\"line\">  debug(<span class=\"string\">`listening for cluster messages, <span class=\"subst\">$&#123;process.pid&#125;</span>`</span>);</span><br><span class=\"line\">  cluster.on(<span class=\"string\">'message'</span>, receiver);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  debug(<span class=\"string\">'not listening for messages, because we are not a master process'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  由上面的源码可以看到，在isPM2Master和cluster.isMaster为true时会注册两个监听函数，当worker进程通过IPC发送消息时，将通过receiver接受消息，并在master中进行写入log的操作。上一节说到，pm2的master是God Daemon进程，进程里肯定不包含任何log4js的调用。那么在使用pm2时，由谁来写日志呢？关键就在于isPM2Master函数。</p>\n<h3 id=\"isPM2Master是如何工作的\"><a href=\"#isPM2Master是如何工作的\" class=\"headerlink\" title=\"isPM2Master是如何工作的\"></a>isPM2Master是如何工作的</h3><p>  那么接下来我们将看看isPM2Master()这个方法的具体实现：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPM2Master</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> config.pm2 &amp;&amp; process.env[config.pm2InstanceVar] === <span class=\"string\">'0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  我们看到有两个判断条件:</p>\n<ul>\n<li>条件一: config.pm2可以通过log4js的配置文件指定，可设置为”pm2=true”</li>\n<li><p>条件二: 从env里取环境变量config.pm2InstanceVar所代表的值，经运行发现默认情况下 pm2InstanceVar = NODE_APP_INSTANCE。</p>\n<p>关于NODE_APP_INSTANCE环境变量，在pm2源码的CHANGE_LOG里有这样一段描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If we start let&apos;s say 4 instances of an app (cluster_mode),</span><br><span class=\"line\">Each app will have a value in process.env.NODE_APP_INSTANCE which will be 0 for the first one,</span><br><span class=\"line\">1, 2 and 3 for the next ones.</span><br></pre></td></tr></table></figure>\n<p>意即，当pm2启动4个用户进程的实例时，这四个进程的process.env.NODE_APP_INSTANCE环境变量值分别为0,1,2,3</p>\n<p><strong> 由此可见，当我们在log4js的配置文件设置pm2=true时，log4js将取NODE_APP_INSTANCE=0的进程作为写日志的主进程，这就避免了多进程写</strong></p>\n</li>\n</ul>\n<h3 id=\"为什么pm2以多进程方式启动时，无法创建日志文件\"><a href=\"#为什么pm2以多进程方式启动时，无法创建日志文件\" class=\"headerlink\" title=\"为什么pm2以多进程方式启动时，无法创建日志文件\"></a>为什么pm2以多进程方式启动时，无法创建日志文件</h3><p>  最终问题回到了文章开头提到的现象，究竟是为什么导致了创建日志文件失败呢，我们看看源码。在configuration.js的createAppender方法里有这么一段：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.disableClustering || cluster.isMaster || (<span class=\"keyword\">this</span>.pm2 &amp;&amp; process.env[<span class=\"keyword\">this</span>.pm2InstanceVar] === <span class=\"string\">'0'</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> appender = appenderModule.configure(</span><br><span class=\"line\">      config,</span><br><span class=\"line\">      layouts,</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.configuredAppenders.get.bind(<span class=\"keyword\">this</span>.configuredAppenders),</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.configuredLevels</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  可见(this.pm2 &amp;&amp; process.env[this.pm2InstanceVar] === ‘0’)就是我们上文提到的isPm2Master方法</p>\n<h3 id=\"问题的解决\"><a href=\"#问题的解决\" class=\"headerlink\" title=\"问题的解决\"></a>问题的解决</h3><p>  由此发现，解决这个问题的方式就是在log4js配置文件里加上pm2=true的选项，具体如下：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log4js.configure(&#123;</span><br><span class=\"line\">  appenders: &#123;</span><br><span class=\"line\">    df: &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'dateFile'</span>,</span><br><span class=\"line\">      filename: <span class=\"string\">'/Users/didi/Github/log4js-node/zhlin-logs/xxx.log'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  categories: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123; <span class=\"attr\">appenders</span>: [<span class=\"string\">'df'</span>], <span class=\"attr\">level</span>: <span class=\"string\">'DEBUG'</span> &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  pm2: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>  近期对logger组件进行升级，使用log4js作为底层日志输出。在开发环境下通过node命令行启动程序，log能正常创建打印。但是在生产环境下，通过pm2启动程序后，发现日志文件无法正常创建。经过散弹枪式编程法跟踪后，发现当实例数量大于1时，日志文件无法正常创建。阅读源码发现是log4js与pm2配合的问题，而log4js的文档中并未提及该问题。</p>\n<h3 id=\"pm2以cluster模式启动程序时到底干了啥\"><a href=\"#pm2以cluster模式启动程序时到底干了啥\" class=\"headerlink\" title=\"pm2以cluster模式启动程序时到底干了啥\"></a>pm2以cluster模式启动程序时到底干了啥</h3><p>  既然上文说到与pm2有关，那么pm2是如何启动进程的呢？以下只讨论cluster模式。<br>  我们都知道cluster模式启动进程时，将会产生一个master进程和N个worker进程，那么pm2在启动应用程序时谁是master，谁是worker？<br>  实际上pm2启动进程时，master是pm2的内部进程，叫做God Daemon进程。所有的用户代码都是以worker进程的方式启动的。<br>  在pm2的lib/God.js里有如一段代码：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.setupMaster(&#123;</span><br><span class=\"line\">  exec : path.resolve(path.dirname(<span class=\"built_in\">module</span>.filename), <span class=\"string\">'ProcessContainer.js'</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  这段代码保证了在调用cluster.fork()方法时，pm2去加载用户代码，并在worker进程中执行。<br>  对应pm2运行原理的分析，这里先告一个段落，接下来我们看看log4js的源码是如何处理多进程写日志以及如何创建日志文件的。</p>\n<h3 id=\"多进程下，该如何写同一个日志文件？\"><a href=\"#多进程下，该如何写同一个日志文件？\" class=\"headerlink\" title=\"多进程下，该如何写同一个日志文件？\"></a>多进程下，该如何写同一个日志文件？</h3><p>  多个进程同时写一个文件时会发生什么呢？参考：<a href=\"https://blog.csdn.net/yangbodong22011/article/details/63064166\" target=\"_blank\" rel=\"noopener\">多进程同时写一个文件会怎样？</a><br>  为了避免多进程同时写一个日志文件，log4js的实现方式是：通过IPC传递消息，由一个进程去写。</p>\n<p>  log4js.configure()方法执行的内部有如下的一段代码：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (config.disableClustering) &#123;</span><br><span class=\"line\">  debug(<span class=\"string\">'Not listening for cluster messages, because clustering disabled.'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isPM2Master()) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// PM2 cluster support</span></span><br><span class=\"line\">  <span class=\"comment\">// PM2 runs everything as workers - install pm2-intercom for this to work.</span></span><br><span class=\"line\">  <span class=\"comment\">// we only want one of the app instances to write logs</span></span><br><span class=\"line\">  debug(<span class=\"string\">`listening for PM2 broadcast messages, <span class=\"subst\">$&#123;process.pid&#125;</span>`</span>);</span><br><span class=\"line\">  process.on(<span class=\"string\">'message'</span>, receiver);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cluster.isMaster) &#123;</span><br><span class=\"line\">  debug(<span class=\"string\">`listening for cluster messages, <span class=\"subst\">$&#123;process.pid&#125;</span>`</span>);</span><br><span class=\"line\">  cluster.on(<span class=\"string\">'message'</span>, receiver);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  debug(<span class=\"string\">'not listening for messages, because we are not a master process'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  由上面的源码可以看到，在isPM2Master和cluster.isMaster为true时会注册两个监听函数，当worker进程通过IPC发送消息时，将通过receiver接受消息，并在master中进行写入log的操作。上一节说到，pm2的master是God Daemon进程，进程里肯定不包含任何log4js的调用。那么在使用pm2时，由谁来写日志呢？关键就在于isPM2Master函数。</p>\n<h3 id=\"isPM2Master是如何工作的\"><a href=\"#isPM2Master是如何工作的\" class=\"headerlink\" title=\"isPM2Master是如何工作的\"></a>isPM2Master是如何工作的</h3><p>  那么接下来我们将看看isPM2Master()这个方法的具体实现：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPM2Master</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> config.pm2 &amp;&amp; process.env[config.pm2InstanceVar] === <span class=\"string\">'0'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  我们看到有两个判断条件:</p>\n<ul>\n<li>条件一: config.pm2可以通过log4js的配置文件指定，可设置为”pm2=true”</li>\n<li><p>条件二: 从env里取环境变量config.pm2InstanceVar所代表的值，经运行发现默认情况下 pm2InstanceVar = NODE_APP_INSTANCE。</p>\n<p>关于NODE_APP_INSTANCE环境变量，在pm2源码的CHANGE_LOG里有这样一段描述:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If we start let&apos;s say 4 instances of an app (cluster_mode),</span><br><span class=\"line\">Each app will have a value in process.env.NODE_APP_INSTANCE which will be 0 for the first one,</span><br><span class=\"line\">1, 2 and 3 for the next ones.</span><br></pre></td></tr></table></figure>\n<p>意即，当pm2启动4个用户进程的实例时，这四个进程的process.env.NODE_APP_INSTANCE环境变量值分别为0,1,2,3</p>\n<p><strong> 由此可见，当我们在log4js的配置文件设置pm2=true时，log4js将取NODE_APP_INSTANCE=0的进程作为写日志的主进程，这就避免了多进程写</strong></p>\n</li>\n</ul>\n<h3 id=\"为什么pm2以多进程方式启动时，无法创建日志文件\"><a href=\"#为什么pm2以多进程方式启动时，无法创建日志文件\" class=\"headerlink\" title=\"为什么pm2以多进程方式启动时，无法创建日志文件\"></a>为什么pm2以多进程方式启动时，无法创建日志文件</h3><p>  最终问题回到了文章开头提到的现象，究竟是为什么导致了创建日志文件失败呢，我们看看源码。在configuration.js的createAppender方法里有这么一段：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.disableClustering || cluster.isMaster || (<span class=\"keyword\">this</span>.pm2 &amp;&amp; process.env[<span class=\"keyword\">this</span>.pm2InstanceVar] === <span class=\"string\">'0'</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> appender = appenderModule.configure(</span><br><span class=\"line\">      config,</span><br><span class=\"line\">      layouts,</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.configuredAppenders.get.bind(<span class=\"keyword\">this</span>.configuredAppenders),</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.configuredLevels</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  可见(this.pm2 &amp;&amp; process.env[this.pm2InstanceVar] === ‘0’)就是我们上文提到的isPm2Master方法</p>\n<h3 id=\"问题的解决\"><a href=\"#问题的解决\" class=\"headerlink\" title=\"问题的解决\"></a>问题的解决</h3><p>  由此发现，解决这个问题的方式就是在log4js配置文件里加上pm2=true的选项，具体如下：<br>  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log4js.configure(&#123;</span><br><span class=\"line\">  appenders: &#123;</span><br><span class=\"line\">    df: &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'dateFile'</span>,</span><br><span class=\"line\">      filename: <span class=\"string\">'/Users/didi/Github/log4js-node/zhlin-logs/xxx.log'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  categories: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123; <span class=\"attr\">appenders</span>: [<span class=\"string\">'df'</span>], <span class=\"attr\">level</span>: <span class=\"string\">'DEBUG'</span> &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  pm2: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"mac安装protobuf2.5.0","date":"2018-06-06T08:48:03.000Z","_content":"### 起因\n编译hadoop2.9.0时提示如下错误：\n```\n[ERROR] Failed to execute goal org.apache.hadoop:hadoop-maven-plugins:2.9.0:protoc (compile-protoc) on project hadoop-common: org.apache.maven.plugin.MojoExecutionException: protoc version is 'libprotoc 3.5.1', expected version is '2.5.0' -> [Help 1]\n```\n\n### 安装步骤\n- 下载源码\n```bash\nwget https://github.com/google/protobuf/releases/download/v2.5.0/protobuf-2.5.0.tar.bz2\n```\n\n- 解压源码\n```bash\ntar xfvj protobuf-2.5.0.tar.bz2\n```\n\n- 配置编译选项\n```bash\ncd protobuf-2.5.0\n./configure CC=clang CXX=clang++ CXXFLAGS='-std=c++11 -stdlib=libc++ -O3 -g' LDFLAGS='-stdlib=libc++' LIBS='-lc++ -lc++abi'\n```\n\n- 编译安装\n```bash\nmake -j 4\nsudo make install\n```","source":"_posts/mac安装protobuf2-5-0.md","raw":"---\ntitle: mac安装protobuf2.5.0\ndate: 2018-06-06 16:48:03\ntags:\n---\n### 起因\n编译hadoop2.9.0时提示如下错误：\n```\n[ERROR] Failed to execute goal org.apache.hadoop:hadoop-maven-plugins:2.9.0:protoc (compile-protoc) on project hadoop-common: org.apache.maven.plugin.MojoExecutionException: protoc version is 'libprotoc 3.5.1', expected version is '2.5.0' -> [Help 1]\n```\n\n### 安装步骤\n- 下载源码\n```bash\nwget https://github.com/google/protobuf/releases/download/v2.5.0/protobuf-2.5.0.tar.bz2\n```\n\n- 解压源码\n```bash\ntar xfvj protobuf-2.5.0.tar.bz2\n```\n\n- 配置编译选项\n```bash\ncd protobuf-2.5.0\n./configure CC=clang CXX=clang++ CXXFLAGS='-std=c++11 -stdlib=libc++ -O3 -g' LDFLAGS='-stdlib=libc++' LIBS='-lc++ -lc++abi'\n```\n\n- 编译安装\n```bash\nmake -j 4\nsudo make install\n```","slug":"mac安装protobuf2-5-0","published":1,"updated":"2018-06-06T08:54:05.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj708y8w0007nzs6dsoc7gps","content":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>编译hadoop2.9.0时提示如下错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ERROR] Failed to execute goal org.apache.hadoop:hadoop-maven-plugins:2.9.0:protoc (compile-protoc) on project hadoop-common: org.apache.maven.plugin.MojoExecutionException: protoc version is &apos;libprotoc 3.5.1&apos;, expected version is &apos;2.5.0&apos; -&gt; [Help 1]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ul>\n<li><p>下载源码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/google/protobuf/releases/download/v2.5.0/protobuf-2.5.0.tar.bz2</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解压源码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar xfvj protobuf-2.5.0.tar.bz2</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置编译选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> protobuf-2.5.0</span><br><span class=\"line\">./configure CC=clang CXX=clang++ CXXFLAGS=<span class=\"string\">'-std=c++11 -stdlib=libc++ -O3 -g'</span> LDFLAGS=<span class=\"string\">'-stdlib=libc++'</span> LIBS=<span class=\"string\">'-lc++ -lc++abi'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -j 4</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>编译hadoop2.9.0时提示如下错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ERROR] Failed to execute goal org.apache.hadoop:hadoop-maven-plugins:2.9.0:protoc (compile-protoc) on project hadoop-common: org.apache.maven.plugin.MojoExecutionException: protoc version is &apos;libprotoc 3.5.1&apos;, expected version is &apos;2.5.0&apos; -&gt; [Help 1]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ul>\n<li><p>下载源码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/google/protobuf/releases/download/v2.5.0/protobuf-2.5.0.tar.bz2</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解压源码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar xfvj protobuf-2.5.0.tar.bz2</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置编译选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> protobuf-2.5.0</span><br><span class=\"line\">./configure CC=clang CXX=clang++ CXXFLAGS=<span class=\"string\">'-std=c++11 -stdlib=libc++ -O3 -g'</span> LDFLAGS=<span class=\"string\">'-stdlib=libc++'</span> LIBS=<span class=\"string\">'-lc++ -lc++abi'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make -j 4</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"node调试参数--debug与--debug-brk的区别","date":"2016-07-25T10:15:50.000Z","_content":"\n#### 问题\n\n  在启动项目调试时，发现web服务器启动极慢，慢到无法忍受。经查找发现在node启动时--debug-brk参数惹的祸。当使用--debug-brk启动调试时，程序将停留在第一行，而且需要等待调试工具连接以后（即http://127.0.0.1:8080/?port=5858返回好久以后，此处还有疑问，为啥devTools已经加载完代码很久了，服务端代码才继续执行下去），服务端代码才正常启动起来，这样浏览器才能正常访问页面。\n\n  因此启动时改用--debug参数，这样在node --debug server命令运行完成后，服务器端的代码都会自动运行完成。浏览器就能正常访问页面了。3Q\n\n\n#### 区别\n\n  **--debug-brk** stops the node program on the first line, meaning it will break before starting the server. You can then connect your debugger and hit Continue to run the program.\n\n  **--debug**  start the debugger but not break at the start. So if you have a debugger line somewhere in asynchronous code, it will still break when it hits it if your debugger is connected.\n\n\n\n\n#### 参考\n  http://stackoverflow.com/questions/20384822/node-debug-brk-app-js-not-functioning\n","source":"_posts/node调试参数-debug与-debug-brk的区别.md","raw":"---\ntitle: node调试参数--debug与--debug-brk的区别\ndate: 2016-07-25 18:15:50\ntags:\n---\n\n#### 问题\n\n  在启动项目调试时，发现web服务器启动极慢，慢到无法忍受。经查找发现在node启动时--debug-brk参数惹的祸。当使用--debug-brk启动调试时，程序将停留在第一行，而且需要等待调试工具连接以后（即http://127.0.0.1:8080/?port=5858返回好久以后，此处还有疑问，为啥devTools已经加载完代码很久了，服务端代码才继续执行下去），服务端代码才正常启动起来，这样浏览器才能正常访问页面。\n\n  因此启动时改用--debug参数，这样在node --debug server命令运行完成后，服务器端的代码都会自动运行完成。浏览器就能正常访问页面了。3Q\n\n\n#### 区别\n\n  **--debug-brk** stops the node program on the first line, meaning it will break before starting the server. You can then connect your debugger and hit Continue to run the program.\n\n  **--debug**  start the debugger but not break at the start. So if you have a debugger line somewhere in asynchronous code, it will still break when it hits it if your debugger is connected.\n\n\n\n\n#### 参考\n  http://stackoverflow.com/questions/20384822/node-debug-brk-app-js-not-functioning\n","slug":"node调试参数-debug与-debug-brk的区别","published":1,"updated":"2017-12-06T08:48:38.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj708y8y0008nzs6zqr98rb5","content":"<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>  在启动项目调试时，发现web服务器启动极慢，慢到无法忍受。经查找发现在node启动时–debug-brk参数惹的祸。当使用–debug-brk启动调试时，程序将停留在第一行，而且需要等待调试工具连接以后（即<a href=\"http://127.0.0.1:8080/?port=5858返回好久以后，此处还有疑问，为啥devTools已经加载完代码很久了，服务端代码才继续执行下去），服务端代码才正常启动起来，这样浏览器才能正常访问页面。\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/?port=5858返回好久以后，此处还有疑问，为啥devTools已经加载完代码很久了，服务端代码才继续执行下去），服务端代码才正常启动起来，这样浏览器才能正常访问页面。</a></p>\n<p>  因此启动时改用–debug参数，这样在node –debug server命令运行完成后，服务器端的代码都会自动运行完成。浏览器就能正常访问页面了。3Q</p>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>  <strong>–debug-brk</strong> stops the node program on the first line, meaning it will break before starting the server. You can then connect your debugger and hit Continue to run the program.</p>\n<p>  <strong>–debug</strong>  start the debugger but not break at the start. So if you have a debugger line somewhere in asynchronous code, it will still break when it hits it if your debugger is connected.</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p>  <a href=\"http://stackoverflow.com/questions/20384822/node-debug-brk-app-js-not-functioning\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/20384822/node-debug-brk-app-js-not-functioning</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>  在启动项目调试时，发现web服务器启动极慢，慢到无法忍受。经查找发现在node启动时–debug-brk参数惹的祸。当使用–debug-brk启动调试时，程序将停留在第一行，而且需要等待调试工具连接以后（即<a href=\"http://127.0.0.1:8080/?port=5858返回好久以后，此处还有疑问，为啥devTools已经加载完代码很久了，服务端代码才继续执行下去），服务端代码才正常启动起来，这样浏览器才能正常访问页面。\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/?port=5858返回好久以后，此处还有疑问，为啥devTools已经加载完代码很久了，服务端代码才继续执行下去），服务端代码才正常启动起来，这样浏览器才能正常访问页面。</a></p>\n<p>  因此启动时改用–debug参数，这样在node –debug server命令运行完成后，服务器端的代码都会自动运行完成。浏览器就能正常访问页面了。3Q</p>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><p>  <strong>–debug-brk</strong> stops the node program on the first line, meaning it will break before starting the server. You can then connect your debugger and hit Continue to run the program.</p>\n<p>  <strong>–debug</strong>  start the debugger but not break at the start. So if you have a debugger line somewhere in asynchronous code, it will still break when it hits it if your debugger is connected.</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p>  <a href=\"http://stackoverflow.com/questions/20384822/node-debug-brk-app-js-not-functioning\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/20384822/node-debug-brk-app-js-not-functioning</a></p>\n"},{"title":"typescript精华","date":"2018-06-01T03:36:23.000Z","_content":"# Typescript精华\n\n### Strict Mode\n\n- noImplicitAny\n如下的代码在严格模式下将会报错，需显示指定someArg的类型\n```\nfunction log(someArg) { // Error : someArg has an implicit `any` type\n  sendDataToServer(someArg);\n}\n```\n- strictNullChecks\n\n下段代码在strict模式下，编译器将提示elem可能为null\n```\n  const elem = document.getElementById('test');\n  elem.innerHTML = 'Hello World';\n```","source":"_posts/typescript精华.md","raw":"---\ntitle: typescript精华\ndate: 2018-06-01 11:36:23\ntags:\n---\n# Typescript精华\n\n### Strict Mode\n\n- noImplicitAny\n如下的代码在严格模式下将会报错，需显示指定someArg的类型\n```\nfunction log(someArg) { // Error : someArg has an implicit `any` type\n  sendDataToServer(someArg);\n}\n```\n- strictNullChecks\n\n下段代码在strict模式下，编译器将提示elem可能为null\n```\n  const elem = document.getElementById('test');\n  elem.innerHTML = 'Hello World';\n```","slug":"typescript精华","published":1,"updated":"2018-06-01T06:03:43.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj708y95000anzs68jwk5h7l","content":"<h1 id=\"Typescript精华\"><a href=\"#Typescript精华\" class=\"headerlink\" title=\"Typescript精华\"></a>Typescript精华</h1><h3 id=\"Strict-Mode\"><a href=\"#Strict-Mode\" class=\"headerlink\" title=\"Strict Mode\"></a>Strict Mode</h3><ul>\n<li><p>noImplicitAny<br>如下的代码在严格模式下将会报错，需显示指定someArg的类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(someArg) &#123; // Error : someArg has an implicit `any` type</span><br><span class=\"line\">  sendDataToServer(someArg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>strictNullChecks</p>\n</li>\n</ul>\n<p>下段代码在strict模式下，编译器将提示elem可能为null<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const elem = document.getElementById(&apos;test&apos;);</span><br><span class=\"line\">elem.innerHTML = &apos;Hello World&apos;;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Typescript精华\"><a href=\"#Typescript精华\" class=\"headerlink\" title=\"Typescript精华\"></a>Typescript精华</h1><h3 id=\"Strict-Mode\"><a href=\"#Strict-Mode\" class=\"headerlink\" title=\"Strict Mode\"></a>Strict Mode</h3><ul>\n<li><p>noImplicitAny<br>如下的代码在严格模式下将会报错，需显示指定someArg的类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(someArg) &#123; // Error : someArg has an implicit `any` type</span><br><span class=\"line\">  sendDataToServer(someArg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>strictNullChecks</p>\n</li>\n</ul>\n<p>下段代码在strict模式下，编译器将提示elem可能为null<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const elem = document.getElementById(&apos;test&apos;);</span><br><span class=\"line\">elem.innerHTML = &apos;Hello World&apos;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"使用SSH Tunnel远程调试Nodejs","date":"2018-05-24T09:01:24.000Z","_content":"\n\n### 环境\n  1. 远程机器\n```\n  host: xx.xx.96.106\n  port: 9000\n  wsport: 9229\n```\n  2. 本地机器\n```\n  host: localhost\n  port: 9221\n```\n\n### 步骤\n  1. 启动远程服务\n```\n  node --inspect server/app.js\n\t# 输出如下信息说明node inspector成功启动\n  # Debugger listening on ws://127.0.0.1:9229/f396b0da-7312-48cd-a933-1ea6f7c1c197\n```\n\n  2. 启动本地SSH Tunnel\n```\n  ssh -L 9221:localhost:9229 xiaoju@10.94.96.106\n```\n\n  3. 启动debugger client，入chrome dev tools 或者 vscode，此处使用dev tools\n\n    浏览器地址栏输入chrome://inspect，点击“configure”按钮，输入“loclahost:9221”，点击“done”按钮，成功启动dev tools\n\n  4. 在dev tools里给想访问的代码打上断点，通过浏览器访问\b远程接口，代码将终止在断点处\n  \n    此处访问：http://xxx.xxx.com:9000/#/list\n\n### 参考\n  https://nodejs.org/en/docs/guides/debugging-getting-started/\n  http://blog.creke.net/722.html\n","source":"_posts/使用SSH-Tunnel远程调试Nodejs.md","raw":"---\ntitle: 使用SSH Tunnel远程调试Nodejs\ndate: 2018-05-24 17:01:24\ntags:\n---\n\n\n### 环境\n  1. 远程机器\n```\n  host: xx.xx.96.106\n  port: 9000\n  wsport: 9229\n```\n  2. 本地机器\n```\n  host: localhost\n  port: 9221\n```\n\n### 步骤\n  1. 启动远程服务\n```\n  node --inspect server/app.js\n\t# 输出如下信息说明node inspector成功启动\n  # Debugger listening on ws://127.0.0.1:9229/f396b0da-7312-48cd-a933-1ea6f7c1c197\n```\n\n  2. 启动本地SSH Tunnel\n```\n  ssh -L 9221:localhost:9229 xiaoju@10.94.96.106\n```\n\n  3. 启动debugger client，入chrome dev tools 或者 vscode，此处使用dev tools\n\n    浏览器地址栏输入chrome://inspect，点击“configure”按钮，输入“loclahost:9221”，点击“done”按钮，成功启动dev tools\n\n  4. 在dev tools里给想访问的代码打上断点，通过浏览器访问\b远程接口，代码将终止在断点处\n  \n    此处访问：http://xxx.xxx.com:9000/#/list\n\n### 参考\n  https://nodejs.org/en/docs/guides/debugging-getting-started/\n  http://blog.creke.net/722.html\n","slug":"使用SSH-Tunnel远程调试Nodejs","published":1,"updated":"2018-05-24T11:01:43.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj708y99000bnzs6ql1m6i3u","content":"<h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><ol>\n<li><p>远程机器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host: xx.xx.96.106</span><br><span class=\"line\">port: 9000</span><br><span class=\"line\">wsport: 9229</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地机器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host: localhost</span><br><span class=\"line\">port: 9221</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ol>\n<li><p>启动远程服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> node --inspect server/app.js</span><br><span class=\"line\"># 输出如下信息说明node inspector成功启动</span><br><span class=\"line\"> # Debugger listening on ws://127.0.0.1:9229/f396b0da-7312-48cd-a933-1ea6f7c1c197</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动本地SSH Tunnel</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -L 9221:localhost:9229 xiaoju@10.94.96.106</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动debugger client，入chrome dev tools 或者 vscode，此处使用dev tools</p>\n<p>浏览器地址栏输入chrome://inspect，点击“configure”按钮，输入“loclahost:9221”，点击“done”按钮，成功启动dev tools</p>\n</li>\n<li><p>在dev tools里给想访问的代码打上断点，通过浏览器访问\b远程接口，代码将终止在断点处</p>\n<p>此处访问：<a href=\"http://xxx.xxx.com:9000/#/list\" target=\"_blank\" rel=\"noopener\">http://xxx.xxx.com:9000/#/list</a></p>\n</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>  <a href=\"https://nodejs.org/en/docs/guides/debugging-getting-started/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/docs/guides/debugging-getting-started/</a><br>  <a href=\"http://blog.creke.net/722.html\" target=\"_blank\" rel=\"noopener\">http://blog.creke.net/722.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><ol>\n<li><p>远程机器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host: xx.xx.96.106</span><br><span class=\"line\">port: 9000</span><br><span class=\"line\">wsport: 9229</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地机器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">host: localhost</span><br><span class=\"line\">port: 9221</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ol>\n<li><p>启动远程服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> node --inspect server/app.js</span><br><span class=\"line\"># 输出如下信息说明node inspector成功启动</span><br><span class=\"line\"> # Debugger listening on ws://127.0.0.1:9229/f396b0da-7312-48cd-a933-1ea6f7c1c197</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动本地SSH Tunnel</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -L 9221:localhost:9229 xiaoju@10.94.96.106</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动debugger client，入chrome dev tools 或者 vscode，此处使用dev tools</p>\n<p>浏览器地址栏输入chrome://inspect，点击“configure”按钮，输入“loclahost:9221”，点击“done”按钮，成功启动dev tools</p>\n</li>\n<li><p>在dev tools里给想访问的代码打上断点，通过浏览器访问\b远程接口，代码将终止在断点处</p>\n<p>此处访问：<a href=\"http://xxx.xxx.com:9000/#/list\" target=\"_blank\" rel=\"noopener\">http://xxx.xxx.com:9000/#/list</a></p>\n</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>  <a href=\"https://nodejs.org/en/docs/guides/debugging-getting-started/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/docs/guides/debugging-getting-started/</a><br>  <a href=\"http://blog.creke.net/722.html\" target=\"_blank\" rel=\"noopener\">http://blog.creke.net/722.html</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjj708y8h0003nzs6q7x7aakw","tag_id":"cjj708y8o0005nzs6cfiu7ybf","_id":"cjj708y950009nzs6aikdauys"}],"Tag":[{"name":"Mac","_id":"cjj708y8o0005nzs6cfiu7ybf"}]}}